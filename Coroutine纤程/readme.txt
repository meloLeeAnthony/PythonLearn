协程，又称微线程，纤程。英文名Coroutine，是一种用户态的轻量级线程

在一个线程中会有很多函数，我们把这些函数称为子程序。

在子程序执行过程中可以中断去执行别的子程序，而别的子程序也可以中断回来继续执行之前的子程序，这个过程就称为协程。
协程拥有自己的寄存器和栈

线程是系统级别，由操作系统调度；而协程则是程序级别，由程序根据需要自己调度

协程的优点：
（1）无需线程上下文切换的开销，协程避免了无意义的调度，由此可以提高性能
    （但也因此，程序员必须自己承担调度的责任，同时，协程也失去了标准线程使用多CPU的能力）
（2）无需原子操作锁定及同步的开销
（3）方便切换控制流，简化编程模型
（4）高并发+高扩展性+低成本：一个CPU支持上万的协程都不是问题。所以很适合用于高并发处理。

协程的缺点：
（1）无法利用多核资源：协程的本质是个单线程,它不能同时将单个CPU的多个核用上。
    协程需要和进程配合才能运行在多CPU上.当然我们日常所编写的绝大部分应用都没有这个必要，除非是cpu密集型应用。
（2）进行阻塞（Blocking）操作（如IO时）会阻塞掉整个程序。

---------------------------------------------------------------------------------------------------------------------------------
yield的使用：Python对协程的支持是通过generator实现的。
    在generator中，不但可以通过for循环来迭代，还可以不断调用next()函数获取由yield语句返回的下一个值

---------------------------------------------------------------------------------------------------------------------------------
asyncio是Python 3.4版本引入的标准库，直接内置了对异步IO的支持
    asyncio的编程模型就是一个消息循环。
    我们从asyncio模块中直接获取一个EventLoop的引用，然后把需要执行的协程扔到EventLoop中执行，就实现了异步IO

---------------------------------------------------------------------------------------------------------------------------------
1、event_loop事件循环：程序开启一个无限的循环，程序员会把一些函数注册到事件循环上。当满足事件发生的时候，调用相应的协程函数
2、coroutine协程：指一个使用async关键字定义的函数，它的调用不会立即执行函数，而是会返回一个协程对象。协程对象需要注册到事件循环，由事件循环调用
3、task任务：一个协程对象就是一个原生可以挂起的函数，任务则是对协程进一步封装，其中包含任务的各种状态
4、future：代表将来执行或没有执行的任务的结果。它和task上没有本质的区别
5、async/await关键字：python3.5用于定义协程的关键字，async定义一个协程，await用于挂起阻塞的异步调用接口

---------------------------------------------------------------------------------------------------------------------------------
asyncio.ensure_future(coroutine)和loop.create_task(coroutine)都可以创建一个task
    run_until_complete参数是一个futrue对象。当传入一个协程，其内部会自动封装成task，task是future的子类。
    isinstance(task, asyncio.Future)将会输出True

---------------------------------------------------------------------------------------------------------------------------------
绑定回调：在task执行完毕的时候可以获取执行的结果，回调的最后一个参数是future对象，通过该对象可以获取协程返回值。
    如果回调需要多个参数，可以通过偏函数导入

---------------------------------------------------------------------------------------------------------------------------------
使用async可以定义协程对象，使用await可以针对耗时的操作进行挂起，就像生成器里的yield一样，函数让出控制权。
协程遇到await，事件循环将会挂起该协程，执行别的协程，直到其他的协程也挂起或者执行完毕，再进行下一个协程的执行。

---------------------------------------------------------------------------------------------------------------------------------
并发和并行一直是容易混淆的概念。
    并发通常指有多个任务需要同时进行，
    并行则是同一时刻有多个任务执行

    用上课来举例就是，
        并发情况下是一个老师在同一时间段辅助不同的人功课;并行则是好几个老师分别同时辅助多个学生功课。

        简而言之就是一个人同时吃三个馒头还是三个人同时分别吃一个的情况，吃一个馒头算一个任务。


---------------------------------------------------------------------------------------------------------------------------------
future对象有几个状态：
（1）Pending：准备就绪，未执行
（2）Running
（3）Done
（4）Cancelled
创建future的时候，task为pending，事件循环调用执行的时候当然就是running，调用完毕自然就是done。
如果需要停止事件循环，就需要先把task取消。可以使用asyncio.Task获取事件循环的task